---
feature: ret-cont-recursive-nix
start-date: 2019-02-01
author: John Ericson (@Ericson2314)
co-authors: (find a buddy later to help our with the RFC)
related-issues: (will contain links to implementation PRs)
---

# Summary
[summary]: #summary

"Ret-cont" recursive Nix is a restricted form of recursive Nix, where one builds a derivations instead of executing builds during the builds.
This avoids some platform-specific relating to nested sandboxing.
More importantly, it prevents imperative and overly linear direct-style build scripts;
easy to write but throwing the benefits of Nix.

# Motivation
[motivation]: #motivation

The benefits of recursive Nix have been described in many places.
One main reason is if we want Nix to function as a build system and package manager, we need upstream packages to use Nix too without duplicating their build systems in Nixpkgs.
The other main reason is other build systems should be translated to Nix without vendoring tons of autogenerated code in Nixpkgs.

"Ret-cont" recursive nix is short for "return-continuation".
Consider direct style recursive "nix-build":
the outer build blocks while the inner one builds, and then continues.
Just as we can CPS-transform programs, reifying the context of a function call as another function passed as an argument, so we can imagine splitting the derivation in two at this blocking point.
This gives the "continuation" part of the name.

But whereas the CPS transformation makes the continuation an argument, the Nix *derivation* language is first order.
Instead, we can produce a derivation which has the callee as a dependency, and continuation drv downstream depending on it.
Since the outer derivation evaluates (builds) the inner derivation rather than calling anything, I deem that it returns the derivation.
This gives the "return" part of the name.

I've always been concerned with the ease of which someone can just "nix-build ...; nix-build ...; nix-build ..." within a derivation with recursive Nix.
This creates a linear chain of dependencies, which isn't terribly performent: shorter critical paths are crucial for parallelism and incrementality and this fails with both.
Building derivations is lot less convenient, but

Additionally, see https://github.com/edolstra/nix/commit/1a27aa7d64ffe6fc36cfca4d82bdf51c4d8cf717 for Eelco's draft implementation of recursive Nix, and the Darwin sandboxing restriction.
Sandboxing and Darwin are crucial to Nix today, and we shouldn't sacrifice either of them.
With "ret-cont" recursive Nix, actual builds are never nested, so we don't need any fancy constraints on the derivation "runtime" (i.e. the code that actually performs and isolates builds).

# Detailed design
[design]: #detailed-design

I defer to https://github.com/edolstra/nix/commit/1a27aa7d64ffe6fc36cfca4d82bdf51c4d8cf717 with the exact details of setting up the daemon, etc.
The meaningful distinction of this plan is how the derivation "handoff" works.
A derivation can call `nix-instantiate` (or really communicate with the daemon however it wants) to create an arbitrary graph of derivations.
It produces outputs which symlink to those derivations.
Each of those outputs would then be replaced with the symlink's output of the same name in a downstream derivation.
\[The substitution of drvs in a downstream derivation reminds me of the substitution of drvs for content hashes with the intensional store.
We should muse on this point when implementing to reduce code and perhaps have good insights.]
Those drvs are then built, perhaps building more derivations like this; it's possible to never terminate but that's the user's fault.
We can detect simple cycles analogous to black holes in thunks: if a derivation produces a redirected derivation creating a cycle, we can error out instead of looping.

# Drawbacks
[drawbacks]: #drawbacks

We shouldn't be so worried about policing good taste in derivations, and allow full recursive Nix.

# Alternatives
[alternatives]: #alternatives

Full recursive Nix (builds within builds), or keeping the status quo and use vendoring.
Important from derivation has been traditionally considered an alternative to this, but I will soon propose an implementation of that relying on this; I know longer consider the two in conflict.

# Unresolved questions
[unresolved]: #unresolved-questions

The exact way the outputs refer to the replacement derivations / their outputs is subject to bikeshedding.

# Future work
[future]: #future-work

A version of IFD that delays evaluation in derivation to keep evaluation non-blocking.
This works on the same principle as this keeps all derivations non-blocking (be they higher order or not).
